/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import Cypher from "@neo4j/cypher-builder";
import { getCypherRelationshipDirection } from "../../../utils/get-relationship-direction";
import mapToDbProperty from "../../../utils/map-to-db-property";
import { filterTruthy } from "../../../utils/utils";
import { checkAuthentication } from "../../authorization/check-authentication";
import { createAuthorizationAfterPredicate, createAuthorizationAfterPredicateField, } from "../../authorization/create-authorization-after-predicate";
import createRelationshipValidationString from "../../create-relationship-validation-string";
export class UnwindCreateVisitor {
    constructor(unwindVar, callbackBucket, context) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.environment = {};
    }
    visitChildren(currentASTNode, unwindVar, parentVar) {
        if (currentASTNode.children) {
            const scope = { unwindVar, parentVar };
            const childrenRefs = currentASTNode.children.map((children) => {
                this.environment[children.id] = scope;
                return children.accept(this);
            });
            return childrenRefs;
        }
        return [];
    }
    visitCreate(create) {
        const labels = create.node.getLabels(this.context);
        const currentNode = new Cypher.Node({
            labels,
        });
        const nestedClauses = this.visitChildren(create, this.unwindVar, currentNode);
        const setProperties = create.nodeProperties.map((property) => fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);
        const createClause = new Cypher.Create(currentNode).set(...setProperties, ...autogeneratedProperties);
        const relationshipValidationClause = new Cypher.Raw((env) => {
            const validationStr = createRelationshipValidationString({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        checkAuthentication({ context: this.context, node: create.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(create.node, this.context, currentNode);
        let authorizationFieldsClause;
        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: create,
            nodeRef: currentNode,
            unwindVar: this.unwindVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = Cypher.concat(new Cypher.With("*"), preComputedSubqueries, new Cypher.With("*").where(predicate));
                }
                authorizationFieldsClause = new Cypher.With("*").where(predicate);
            }
        }
        const clause = Cypher.concat(...filterTruthy([
            createClause,
            ...nestedClauses,
            authNodeClause,
            authorizationFieldsClause,
            relationshipValidationClause,
            new Cypher.Return(currentNode),
        ]));
        this.rootNode = currentNode;
        this.clause = new Cypher.Call(clause).importWith(this.unwindVar);
        return this.clause;
    }
    visitNestedCreate(nestedCreate) {
        const scope = this.getScope(nestedCreate.id);
        const parentVar = scope.parentVar;
        const unwindVar = scope.unwindVar;
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new Cypher.With(parentVar, unwindVar);
        const createUnwindVar = new Cypher.Variable();
        const createUnwindClause = new Cypher.Unwind([
            unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new Cypher.Node({
            labels,
        });
        const nodeVar = new Cypher.Variable();
        const edgeVar = new Cypher.Variable();
        const withCreate = new Cypher.With([createUnwindVar.property("node"), nodeVar], [createUnwindVar.property("edge"), edgeVar], parentVar);
        const nestedClauses = this.visitChildren(nestedCreate, nodeVar, currentNode);
        const createClause = new Cypher.Create(currentNode);
        const relationField = relationship[0];
        if (!relationField)
            throw new Error("Transpile error: No relationship found");
        const relationshipVar = new Cypher.Relationship({ type: relationField.type });
        const direction = getCypherRelationshipDirection(relationField);
        const relationshipPattern = new Cypher.Pattern(parentVar)
            .withoutLabels()
            .related(relationshipVar)
            .withDirection(direction)
            .to(currentNode)
            .withoutLabels();
        const mergeClause = new Cypher.Merge(relationshipPattern);
        const setPropertiesNode = nestedCreate.nodeProperties.map((property) => fieldToSetParam(node, currentNode, property, nodeVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);
        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties
                .map((property) => {
                if (nestedCreate.edge) {
                    return fieldToSetParam(nestedCreate.edge, relationshipVar, property, edgeVar.property(property));
                }
            })
                .filter((v) => !!v);
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipVar);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }
        const subQueryStatements = [
            blockWith,
            createUnwindClause,
            withCreate,
            createClause,
            mergeClause,
        ];
        const relationshipValidationClause = new Cypher.Raw((env) => {
            const validationStr = createRelationshipValidationString({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        checkAuthentication({ context: this.context, node: nestedCreate.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(nestedCreate.node, this.context, currentNode);
        let authorizationFieldsClause;
        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: nestedCreate,
            nodeRef: currentNode,
            unwindVar: nodeVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = Cypher.concat(new Cypher.With("*"), preComputedSubqueries, new Cypher.With("*").where(predicate));
                }
                authorizationFieldsClause = new Cypher.With("*").where(predicate);
            }
        }
        subQueryStatements.push(...nestedClauses);
        if (authNodeClause) {
            subQueryStatements.push(authNodeClause);
        }
        if (authorizationFieldsClause) {
            subQueryStatements.push(authorizationFieldsClause);
        }
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new Cypher.Return([Cypher.collect(Cypher.Null), new Cypher.Variable()]));
        const subQuery = Cypher.concat(...subQueryStatements);
        const callClause = new Cypher.Call(subQuery);
        const outsideWith = new Cypher.With(parentVar, unwindVar);
        return Cypher.concat(outsideWith, callClause);
    }
    getAuthNodeClause(node, context, nodeRef) {
        const authorizationPredicateReturn = createAuthorizationAfterPredicate({
            context,
            nodes: [
                {
                    variable: nodeRef,
                    node,
                },
            ],
            operations: ["CREATE"],
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    return Cypher.concat(new Cypher.With("*"), preComputedSubqueries, new Cypher.With("*").where(predicate));
                }
                return new Cypher.With("*").where(predicate);
            }
        }
    }
    getAuthorizationFieldClause({ astNode, nodeRef, unwindVar, }) {
        const authorizationPredicates = [];
        let authorizationSubquery = undefined;
        const usedAuthFields = astNode.nodeProperties
            .flatMap((property) => {
            return astNode.node.primitiveFields.filter((authField) => authField.fieldName === property);
        })
            .filter((n) => n);
        for (const field of usedAuthFields) {
            checkAuthentication({
                context: this.context,
                node: astNode.node,
                targetOperations: ["CREATE"],
                field: field.fieldName,
            });
            const authorizationPredicateReturn = createAuthorizationAfterPredicateField({
                context: this.context,
                nodes: [
                    {
                        variable: nodeRef,
                        node: astNode.node,
                        fieldName: field.fieldName,
                    },
                ],
                operations: ["CREATE"],
                conditionForEvaluation: Cypher.isNotNull(unwindVar.property(field.fieldName)),
            });
            if (authorizationPredicateReturn) {
                const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
                if (predicate) {
                    if (preComputedSubqueries && !preComputedSubqueries.empty) {
                        authorizationSubquery = Cypher.concat(authorizationSubquery, preComputedSubqueries);
                    }
                    authorizationPredicates.push(predicate);
                }
            }
        }
        return {
            predicate: Cypher.and(...authorizationPredicates),
            preComputedSubqueries: authorizationSubquery,
        };
    }
    getScope(identifier) {
        const scope = this.environment[identifier];
        if (!scope) {
            throw new Error("Transpile error: No scope found");
        }
        return scope;
    }
    /*
     * Returns the Cypher Reference of the root Nodes and the Cypher Clause generated
     */
    build() {
        return [this.rootNode, this.clause];
    }
}
function getAutoGeneratedFields(graphQLElement, cypherNodeRef) {
    const setParams = [];
    const timestampedFields = graphQLElement.temporalFields.filter((x) => ["DateTime", "Time"].includes(x.typeMeta.name) && x.timestamps?.includes("CREATE"));
    timestampedFields.forEach((field) => {
        // DateTime -> datetime(); Time -> time()
        const relatedCypherExpression = Cypher[field.typeMeta.name.toLowerCase()]();
        if (field.dbPropertyName) {
            setParams.push([cypherNodeRef.property(field.dbPropertyName), relatedCypherExpression]);
        }
    });
    const autogeneratedIdFields = graphQLElement.primitiveFields.filter((x) => x.autogenerate);
    autogeneratedIdFields.forEach((field) => {
        if (field.dbPropertyName) {
            setParams.push([cypherNodeRef.property(field.dbPropertyName), Cypher.randomUUID()]);
        }
    });
    return setParams;
}
function fieldToSetParam(graphQLElement, cypherNodeRef, key, value) {
    const pointField = graphQLElement.pointFields.find((x) => key === x.fieldName);
    const dbName = mapToDbProperty(graphQLElement, key);
    if (pointField) {
        if (pointField.typeMeta.array) {
            const comprehensionVar = new Cypher.Variable();
            const mapPoint = Cypher.point(comprehensionVar);
            const expression = new Cypher.ListComprehension(comprehensionVar, value).map(mapPoint);
            return [cypherNodeRef.property(dbName), expression];
        }
        return [cypherNodeRef.property(dbName), Cypher.point(value)];
    }
    return [cypherNodeRef.property(dbName), value];
}
